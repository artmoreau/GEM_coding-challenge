# -*- coding: utf-8 -*-
"""
Created on Tue Dec  7 18:51:50 2021

@author: Arthur-Pc
"""

import numpy as np

def merite_order(powerplants,price_gas,price_co2,price_kerosine):
    
    ''' 
    Given a list of powerplants and the price of each combustible,
    Return a tab with correspond to the index of the powerplants 
    sorted by merite-order.
    '''
    
    #Each entry gives the prices in euro to produces 1 MWh for the powerplants with the same index
    price_powerplants = np.zeros(len(powerplants))
    
    for i,powerplant in enumerate(powerplants) :
        
        efficiency = powerplant.get('efficiency')
        type_powerplant = powerplant.get('type')
        if(type_powerplant == 'gasfired') :
            #for each MWh of electricity generated by gasfired, we produce 0.3 ton of CO2 that also have a cost
            price = price_gas/efficiency + 0.3*price_co2
        elif(type_powerplant == 'turbojet') :
            price = price_kerosine/efficiency
        else : #it's a windturbine
            price = 0
        price_powerplants[i] = price
    
    return np.argsort(price_powerplants)

def power_range(powerplants,wind) :
    
    '''
    Given a list of powerplants, return to list, pmin and pmax.
    The minimum and maximum amount of power the powerplant can generate
    '''
    
    nbr_powerplants = len(powerplants)
    pmin =  np.zeros(nbr_powerplants)
    pmax =  np.zeros(nbr_powerplants)
    for i,powerplant in enumerate(powerplants) :
        pmin[i] = powerplants[i].get('pmin')
        if(powerplants[i].get('type') == 'windturbine') :
            pmax[i] = powerplants[i].get('pmax') * wind/100
        else :
            pmax[i] = powerplants[i].get('pmax')
            
    return pmin,pmax

def algo1(load,powerplants,sorted_powerplants,pmin,pmax):
    
    '''
    Return a list of power for each powerplants to reach the load.
    Return 0 if the algo dont find a solution.
    '''
    
    # First try : uses powerplants at maximum capacity by merite_order.
    # until we reach the load.
    
    # Find a good solutions (not always the best) but does not always find a solution.
    
    # power for each powerplant
    powers =  np.zeros(len(powerplants))
    total = 0
    
    for i in sorted_powerplants :
            
        if total + pmax[i] <= load :
            powers[i] = pmax[i]
            total += pmax[i]
        elif total + pmin[i] > load :
            pass
        else : # The account is good
            powers[i] = load - total
            total = load
            return powers
    
    return 0 # L'algorithme n'as pas trouvé de solution
    
def algo2(load,powerplants,sorted_powerplants,pmin,pmax):
    
    '''
    Return a list of power for each powerplants to reach the load.
    Return 0 if the algo dont find a solution.
    '''
    
    # Second try : The idea is to strat with a (bad) solution computed by
    # taking for each powerplants is minimum power value until we reach the load. 
    # And then at each step we improve the solution by 
    # swapping expensive energy for less expensive.
    
    # Always find a solutions (if is it possible) but the solution is not always the best
    
    # power for each powerplant
    powers = np.zeros(len(powerplants))
    total = 0
    
    for i in sorted_powerplants :
        if total + pmin[i] <= load :
            powers[i] = pmin[i]
            total += pmin[i]
    
    for i in sorted_powerplants :
        if total + (pmax[i] - pmin[i]) <= load :
            powers[i] = pmax[i]
            total = total + (pmax[i] - pmin[i])
        else :
            powers[i] = powers[i] + (load - total)
            total = load
    
    if(total != load) :
        return 0 # L'algorithme n'as pas trouvé de solution
    
    # At this step we have a solution (probably bad) (total = load).
    # We will try to optimize the solution by swapping expensive energy 
    # for cheaper energy.
    
    for i in sorted_powerplants[-1::-1] : # Reverse the order
        
        goals = powers[i]
        reste = 0
        
        for j in sorted_powerplants :
            if j == i :
                break
            reste = reste + (pmax[j] - powers[j])
            if(reste >= goals) :
                break
            
        if(reste >= goals) : # We can trade the more expensive energy for cheaper ones
            powers[i] = 0
            for j in sorted_powerplants :
                if (powers[j] != pmax[j]):
                    if (pmax[j] - powers[j] <= goals) :
                        goals = goals - (pmax[j] - powers[j])
                        powers[j] = pmax[j]
                    else :
                        powers[j] = powers[j] + goals
                        goals = 0
        else :
            break
            
    return powers

def solver(load,powerplants,price_gas,price_co2,price_kerosine,wind) :
    
    '''
    Given a load, a list of powerplants, the wind and the price for each combustible
    Return the power for each powerplants as a list of float.
    '''
        
    sorted_powerplants = merite_order(powerplants,price_gas,price_co2,price_kerosine)
    pmin,pmax = power_range(powerplants,wind)
    

    return algo2(load,powerplants,sorted_powerplants,pmin,pmax)